{"version":3,"file":"vfs.cjs.production.min.js","sources":["../src/index.ts"],"sourcesContent":["type System = import(\"typescript\").System\ntype CompilerOptions = import(\"typescript\").CompilerOptions\ntype CustomTransformers = import(\"typescript\").CustomTransformers\ntype LanguageServiceHost = import(\"typescript\").LanguageServiceHost\ntype CompilerHost = import(\"typescript\").CompilerHost\ntype SourceFile = import(\"typescript\").SourceFile\ntype TS = typeof import(\"typescript\")\n\ntype FetchLike = (url: string) => Promise<{ json(): Promise<any>; text(): Promise<string> }>\n\ninterface LocalStorageLike {\n  getItem(key: string): string | null\n  setItem(key: string, value: string): void\n  removeItem(key: string): void\n}\n\ndeclare var localStorage: LocalStorageLike | undefined;\ndeclare var fetch: FetchLike | undefined;\n\nlet hasLocalStorage = false\ntry {\n  hasLocalStorage = typeof localStorage !== `undefined`\n} catch (error) { }\n\nconst hasProcess = typeof process !== `undefined`\nconst shouldDebug = (hasLocalStorage && localStorage!.getItem(\"DEBUG\")) || (hasProcess && process.env.DEBUG)\nconst debugLog = shouldDebug ? console.log : (_message?: any, ..._optionalParams: any[]) => \"\"\n\nexport interface VirtualTypeScriptEnvironment {\n  sys: System\n  languageService: import(\"typescript\").LanguageService\n  getSourceFile: (fileName: string) => import(\"typescript\").SourceFile | undefined\n  createFile: (fileName: string, content: string) => void\n  updateFile: (fileName: string, content: string, replaceTextSpan?: import(\"typescript\").TextSpan) => void\n  deleteFile: (fileName: string) => void\n}\n\n/**\n * Makes a virtual copy of the TypeScript environment. This is the main API you want to be using with\n * @typescript/vfs. A lot of the other exposed functions are used by this function to get set up.\n *\n * @param sys an object which conforms to the TS Sys (a shim over read/write access to the fs)\n * @param rootFiles a list of files which are considered inside the project\n * @param ts a copy pf the TypeScript module\n * @param compilerOptions the options for this compiler run\n * @param customTransformers custom transformers for this compiler run\n */\n\nexport function createVirtualTypeScriptEnvironment(\n  sys: System,\n  rootFiles: string[],\n  ts: TS,\n  compilerOptions: CompilerOptions = {},\n  customTransformers?: CustomTransformers\n): VirtualTypeScriptEnvironment {\n  const mergedCompilerOpts = { ...defaultCompilerOptions(ts), ...compilerOptions }\n\n  const { languageServiceHost, updateFile, deleteFile } = createVirtualLanguageServiceHost(\n    sys,\n    rootFiles,\n    mergedCompilerOpts,\n    ts,\n    customTransformers\n  )\n  const languageService = ts.createLanguageService(languageServiceHost)\n  const diagnostics = languageService.getCompilerOptionsDiagnostics()\n\n  if (diagnostics.length) {\n    const compilerHost = createVirtualCompilerHost(sys, compilerOptions, ts)\n    throw new Error(ts.formatDiagnostics(diagnostics, compilerHost.compilerHost))\n  }\n\n  return {\n    // @ts-ignore\n    name: \"vfs\",\n    sys,\n    languageService,\n    getSourceFile: fileName => languageService.getProgram()?.getSourceFile(fileName),\n\n    createFile: (fileName, content) => {\n      updateFile(ts.createSourceFile(fileName, content, mergedCompilerOpts.target!, false))\n    },\n    updateFile: (fileName, content, optPrevTextSpan) => {\n      const prevSourceFile = languageService.getProgram()!.getSourceFile(fileName)\n      if (!prevSourceFile) {\n        throw new Error(\"Did not find a source file for \" + fileName)\n      }\n      const prevFullContents = prevSourceFile.text\n\n      // TODO: Validate if the default text span has a fencepost error?\n      const prevTextSpan = optPrevTextSpan ?? ts.createTextSpan(0, prevFullContents.length)\n      const newText =\n        prevFullContents.slice(0, prevTextSpan.start) +\n        content +\n        prevFullContents.slice(prevTextSpan.start + prevTextSpan.length)\n      const newSourceFile = ts.updateSourceFile(prevSourceFile, newText, {\n        span: prevTextSpan,\n        newLength: content.length,\n      })\n\n      updateFile(newSourceFile)\n    },\n    deleteFile(fileName) {\n      const sourceFile = languageService.getProgram()!.getSourceFile(fileName)\n      if (sourceFile) {\n        deleteFile(sourceFile)\n      }\n    }\n  }\n}\n\n// TODO: This could be replaced by grabbing: https://github.com/microsoft/TypeScript/blob/main/src/lib/libs.json\n// and then using that to generate the list of files from the server, but it is not included in the npm package\n\n/**\n * Grab the list of lib files for a particular target, will return a bit more than necessary (by including\n * the dom) but that's OK, we're really working with the constraint that you can't get a list of files\n * when running in a browser.\n *\n * @param target The compiler settings target baseline\n * @param ts A copy of the TypeScript module\n */\nexport const knownLibFilesForCompilerOptions = (compilerOptions: CompilerOptions, ts: TS) => {\n  const target = compilerOptions.target || ts.ScriptTarget.ES5\n  const lib = compilerOptions.lib || []\n\n  // Note that this will include files which can't be found for particular versions of TS\n  // TODO: Replace this with some sort of API call if https://github.com/microsoft/TypeScript/pull/54011\n  // or similar is merged.\n  const files = [\n    \"lib.d.ts\",\n    \"lib.core.d.ts\",\n    \"lib.decorators.d.ts\",\n    \"lib.decorators.legacy.d.ts\",\n    \"lib.dom.asynciterable.d.ts\",\n    \"lib.dom.d.ts\",\n    \"lib.dom.iterable.d.ts\",\n    \"lib.webworker.asynciterable.d.ts\",\n    \"lib.webworker.d.ts\",\n    \"lib.webworker.importscripts.d.ts\",\n    \"lib.webworker.iterable.d.ts\",\n    \"lib.scripthost.d.ts\",\n    \"lib.es5.d.ts\",\n    \"lib.es6.d.ts\",\n    \"lib.es7.d.ts\",\n    \"lib.core.es6.d.ts\",\n    \"lib.core.es7.d.ts\",\n    \"lib.es2015.collection.d.ts\",\n    \"lib.es2015.core.d.ts\",\n    \"lib.es2015.d.ts\",\n    \"lib.es2015.generator.d.ts\",\n    \"lib.es2015.iterable.d.ts\",\n    \"lib.es2015.promise.d.ts\",\n    \"lib.es2015.proxy.d.ts\",\n    \"lib.es2015.reflect.d.ts\",\n    \"lib.es2015.symbol.d.ts\",\n    \"lib.es2015.symbol.wellknown.d.ts\",\n    \"lib.es2016.array.include.d.ts\",\n    \"lib.es2016.d.ts\",\n    \"lib.es2016.full.d.ts\",\n    \"lib.es2016.intl.d.ts\",\n    \"lib.es2017.arraybuffer.d.ts\",\n    \"lib.es2017.d.ts\",\n    \"lib.es2017.date.d.ts\",\n    \"lib.es2017.full.d.ts\",\n    \"lib.es2017.intl.d.ts\",\n    \"lib.es2017.object.d.ts\",\n    \"lib.es2017.sharedmemory.d.ts\",\n    \"lib.es2017.string.d.ts\",\n    \"lib.es2017.typedarrays.d.ts\",\n    \"lib.es2018.asyncgenerator.d.ts\",\n    \"lib.es2018.asynciterable.d.ts\",\n    \"lib.es2018.d.ts\",\n    \"lib.es2018.full.d.ts\",\n    \"lib.es2018.intl.d.ts\",\n    \"lib.es2018.promise.d.ts\",\n    \"lib.es2018.regexp.d.ts\",\n    \"lib.es2019.array.d.ts\",\n    \"lib.es2019.d.ts\",\n    \"lib.es2019.full.d.ts\",\n    \"lib.es2019.intl.d.ts\",\n    \"lib.es2019.object.d.ts\",\n    \"lib.es2019.string.d.ts\",\n    \"lib.es2019.symbol.d.ts\",\n    \"lib.es2020.bigint.d.ts\",\n    \"lib.es2020.d.ts\",\n    \"lib.es2020.date.d.ts\",\n    \"lib.es2020.full.d.ts\",\n    \"lib.es2020.intl.d.ts\",\n    \"lib.es2020.number.d.ts\",\n    \"lib.es2020.promise.d.ts\",\n    \"lib.es2020.sharedmemory.d.ts\",\n    \"lib.es2020.string.d.ts\",\n    \"lib.es2020.symbol.wellknown.d.ts\",\n    \"lib.es2021.d.ts\",\n    \"lib.es2021.full.d.ts\",\n    \"lib.es2021.intl.d.ts\",\n    \"lib.es2021.promise.d.ts\",\n    \"lib.es2021.string.d.ts\",\n    \"lib.es2021.weakref.d.ts\",\n    \"lib.es2022.array.d.ts\",\n    \"lib.es2022.d.ts\",\n    \"lib.es2022.error.d.ts\",\n    \"lib.es2022.full.d.ts\",\n    \"lib.es2022.intl.d.ts\",\n    \"lib.es2022.object.d.ts\",\n    \"lib.es2022.regexp.d.ts\",\n    \"lib.es2022.sharedmemory.d.ts\",\n    \"lib.es2022.string.d.ts\",\n    \"lib.es2023.array.d.ts\",\n    \"lib.es2023.collection.d.ts\",\n    \"lib.es2023.d.ts\",\n    \"lib.es2023.full.d.ts\",\n    \"lib.es2023.intl.d.ts\",\n    \"lib.es2024.arraybuffer.d.ts\",\n    \"lib.es2024.collection.d.ts\",\n    \"lib.es2024.d.ts\",\n    \"lib.es2024.full.d.ts\",\n    \"lib.es2024.object.d.ts\",\n    \"lib.es2024.promise.d.ts\",\n    \"lib.es2024.regexp.d.ts\",\n    \"lib.es2024.sharedmemory.d.ts\",\n    \"lib.es2024.string.d.ts\",\n    \"lib.esnext.array.d.ts\",\n    \"lib.esnext.asynciterable.d.ts\",\n    \"lib.esnext.bigint.d.ts\",\n    \"lib.esnext.collection.d.ts\",\n    \"lib.esnext.d.ts\",\n    \"lib.esnext.decorators.d.ts\",\n    \"lib.esnext.disposable.d.ts\",\n    \"lib.esnext.float16.d.ts\",\n    \"lib.esnext.full.d.ts\",\n    \"lib.esnext.intl.d.ts\",\n    \"lib.esnext.iterator.d.ts\",\n    \"lib.esnext.object.d.ts\",\n    \"lib.esnext.promise.d.ts\",\n    \"lib.esnext.regexp.d.ts\",\n    \"lib.esnext.string.d.ts\",\n    \"lib.esnext.symbol.d.ts\",\n    \"lib.esnext.weakref.d.ts\"\n  ]\n\n  const targetToCut = ts.ScriptTarget[target]\n  const matches = files.filter(f => f.startsWith(`lib.${targetToCut.toLowerCase()}`))\n  const targetCutIndex = files.indexOf(matches.pop()!)\n\n  const getMax = (array: number[]) =>\n    array && array.length ? array.reduce((max, current) => (current > max ? current : max)) : undefined\n\n  // Find the index for everything in\n  const indexesForCutting = lib.map(lib => {\n    const matches = files.filter(f => f.startsWith(`lib.${lib.toLowerCase()}`))\n    if (matches.length === 0) return 0\n\n    const cutIndex = files.indexOf(matches.pop()!)\n    return cutIndex\n  })\n\n  const libCutIndex = getMax(indexesForCutting) || 0\n\n  const finalCutIndex = Math.max(targetCutIndex, libCutIndex)\n  return files.slice(0, finalCutIndex + 1)\n}\n\n/**\n * Sets up a Map with lib contents by grabbing the necessary files from\n * the local copy of typescript via the file system.\n *\n * The first two args are un-used, but kept around so as to not cause a\n * semver major bump for no gain to module users.\n */\nexport const createDefaultMapFromNodeModules = (\n  _compilerOptions: CompilerOptions,\n  _ts?: typeof import(\"typescript\"),\n  tsLibDirectory?: string\n) => {\n  const path = requirePath()\n  const fs = requireFS()\n\n  const getLib = (name: string) => {\n    const lib = tsLibDirectory || path.dirname(require.resolve(\"typescript\"))\n    return fs.readFileSync(path.join(lib, name), \"utf8\")\n  }\n\n  const isDtsFile = (file: string) => /\\.d\\.([^\\.]+\\.)?[cm]?ts$/i.test(file)\n\n  const libFiles = fs.readdirSync(tsLibDirectory || path.dirname(require.resolve(\"typescript\")))\n  const knownLibFiles = libFiles.filter(f => f.startsWith(\"lib.\") && isDtsFile(f))\n\n  const fsMap = new Map<string, string>()\n  knownLibFiles.forEach(lib => {\n    fsMap.set(\"/\" + lib, getLib(lib))\n  })\n  return fsMap\n}\n\n/**\n * Adds recursively files from the FS into the map based on the folder\n */\nexport const addAllFilesFromFolder = (map: Map<string, string>, workingDir: string): void => {\n  const path = requirePath()\n  const fs = requireFS()\n\n  const walk = function (dir: string) {\n    let results: string[] = []\n    const list = fs.readdirSync(dir)\n    list.forEach(function (file: string) {\n      file = path.join(dir, file)\n      const stat = fs.statSync(file)\n      if (stat && stat.isDirectory()) {\n        /* Recurse into a subdirectory */\n        results = results.concat(walk(file))\n      } else {\n        /* Is a file */\n        results.push(file)\n      }\n    })\n    return results\n  }\n\n  const allFiles = walk(workingDir)\n\n  allFiles.forEach(lib => {\n    const fsPath = \"/node_modules/@types\" + lib.replace(workingDir, \"\")\n    const content = fs.readFileSync(lib, \"utf8\")\n    const validExtensions = [\".ts\", \".tsx\"]\n\n    if (validExtensions.includes(path.extname(fsPath))) {\n      map.set(fsPath, content)\n    }\n  })\n}\n\n/** Adds all files from node_modules/@types into the FS Map */\nexport const addFilesForTypesIntoFolder = (map: Map<string, string>) =>\n  addAllFilesFromFolder(map, \"node_modules/@types\")\n\nexport interface LZString {\n  compressToUTF16(input: string): string\n  decompressFromUTF16(compressed: string): string\n}\n\n/**\n * Create a virtual FS Map with the lib files from a particular TypeScript\n * version based on the target, Always includes dom ATM.\n *\n * @param options The compiler target, which dictates the libs to set up\n * @param version the versions of TypeScript which are supported\n * @param cache should the values be stored in local storage\n * @param ts a copy of the typescript import\n * @param lzstring an optional copy of the lz-string import\n * @param fetcher an optional replacement for the global fetch function (tests mainly)\n * @param storer an optional replacement for the localStorage global (tests mainly)\n */\nexport const createDefaultMapFromCDN = (\n  options: CompilerOptions,\n  version: string,\n  cache: boolean,\n  ts: TS,\n  lzstring?: LZString,\n  fetcher?: FetchLike,\n  storer?: LocalStorageLike\n) => {\n  const fetchlike = fetcher || fetch!\n  const fsMap = new Map<string, string>()\n  const files = knownLibFilesForCompilerOptions(options, ts)\n  const prefix = `https://playgroundcdn.typescriptlang.org/cdn/${version}/typescript/lib/`\n\n  function zip(str: string) {\n    return lzstring ? lzstring.compressToUTF16(str) : str\n  }\n\n  function unzip(str: string) {\n    return lzstring ? lzstring.decompressFromUTF16(str) : str\n  }\n\n  // Map the known libs to a node fetch promise, then return the contents\n  function uncached() {\n    return (\n      Promise.all(files.map(lib => fetchlike(prefix + lib).then(resp => resp.text())))\n        .then(contents => {\n          contents.forEach((text, index) => fsMap.set(\"/\" + files[index], text))\n        })\n        // Return a NOOP for .d.ts files which aren't in the current build of TypeScript\n        .catch(() => { })\n    )\n  }\n\n  // A localstorage and lzzip aware version of the lib files\n  function cached() {\n    const storelike = storer || localStorage!\n\n    const keys = Object.keys(storelike)\n    keys.forEach(key => {\n      // Remove anything which isn't from this version\n      if (key.startsWith(\"ts-lib-\") && !key.startsWith(\"ts-lib-\" + version)) {\n        storelike.removeItem(key)\n      }\n    })\n\n    return Promise.all(\n      files.map(lib => {\n        const cacheKey = `ts-lib-${version}-${lib}`\n        const content = storelike.getItem(cacheKey)\n\n        if (!content) {\n          // Make the API call and store the text concent in the cache\n          return (\n            fetchlike(prefix + lib)\n              .then(resp => resp.text())\n              .then(t => {\n                storelike.setItem(cacheKey, zip(t))\n                return t\n              })\n              // Return a NOOP for .d.ts files which aren't in the current build of TypeScript\n              .catch(() => { })\n          )\n        } else {\n          return Promise.resolve(unzip(content))\n        }\n      })\n    ).then(contents => {\n      contents.forEach((text, index) => {\n        if (text) {\n          const name = \"/\" + files[index]\n          fsMap.set(name, text)\n        }\n      })\n    })\n  }\n\n  const func = cache ? cached : uncached\n  return func().then(() => fsMap)\n}\n\nfunction notImplemented(methodName: string): any {\n  throw new Error(`Method '${methodName}' is not implemented.`)\n}\n\nfunction audit<ArgsT extends any[], ReturnT>(\n  name: string,\n  fn: (...args: ArgsT) => ReturnT\n): (...args: ArgsT) => ReturnT {\n  return (...args) => {\n    const res = fn(...args)\n\n    const smallres = typeof res === \"string\" ? res.slice(0, 80) + \"...\" : res\n    debugLog(\"> \" + name, ...args)\n    debugLog(\"< \" + smallres)\n\n    return res\n  }\n}\n\n/** The default compiler options if TypeScript could ever change the compiler options */\nconst defaultCompilerOptions = (ts: typeof import(\"typescript\")): CompilerOptions => {\n  return {\n    ...ts.getDefaultCompilerOptions(),\n    jsx: ts.JsxEmit.React,\n    strict: true,\n    esModuleInterop: true,\n    module: ts.ModuleKind.ESNext,\n    suppressOutputPathCheck: true,\n    skipLibCheck: true,\n    skipDefaultLibCheck: true,\n    moduleResolution: ts.ModuleResolutionKind.NodeJs,\n  }\n}\n\n// \"/DOM.d.ts\" => \"/lib.dom.d.ts\"\nconst libize = (path: string) => path.replace(\"/\", \"/lib.\").toLowerCase()\n\n/**\n * Creates an in-memory System object which can be used in a TypeScript program, this\n * is what provides read/write aspects of the virtual fs\n */\nexport function createSystem(files: Map<string, string>): System {\n  return {\n    args: [],\n    createDirectory: () => notImplemented(\"createDirectory\"),\n    // TODO: could make a real file tree\n    directoryExists: audit(\"directoryExists\", directory => {\n      return Array.from(files.keys()).some(path => path.startsWith(directory))\n    }),\n    exit: () => notImplemented(\"exit\"),\n    fileExists: audit(\"fileExists\", fileName => files.has(fileName) || files.has(libize(fileName))),\n    getCurrentDirectory: () => \"/\",\n    getDirectories: () => [],\n    getExecutingFilePath: () => notImplemented(\"getExecutingFilePath\"),\n    readDirectory: audit(\"readDirectory\", directory => (directory === \"/\" ? Array.from(files.keys()) : [])),\n    readFile: audit(\"readFile\", fileName => files.get(fileName) ?? files.get(libize(fileName))),\n    resolvePath: path => path,\n    newLine: \"\\n\",\n    useCaseSensitiveFileNames: true,\n    write: () => notImplemented(\"write\"),\n    writeFile: (fileName, contents) => {\n      files.set(fileName, contents)\n    },\n    deleteFile: (fileName) => {\n      files.delete(fileName)\n    },\n  }\n}\n\n/**\n * Creates a file-system backed System object which can be used in a TypeScript program, you provide\n * a set of virtual files which are prioritised over the FS versions, then a path to the root of your\n * project (basically the folder your node_modules lives)\n */\nexport function createFSBackedSystem(\n  files: Map<string, string>,\n  _projectRoot: string,\n  ts: TS,\n  tsLibDirectory?: string\n): System {\n  // We need to make an isolated folder for the tsconfig, but also need to be able to resolve the\n  // existing node_modules structures going back through the history\n  const root = _projectRoot + \"/vfs\"\n  const path = requirePath()\n\n  // The default System in TypeScript\n  const nodeSys = ts.sys\n  const tsLib = tsLibDirectory ?? path.dirname(require.resolve(\"typescript\"))\n\n  return {\n    // @ts-ignore\n    name: \"fs-vfs\",\n    root,\n    args: [],\n    createDirectory: () => notImplemented(\"createDirectory\"),\n    // TODO: could make a real file tree\n    directoryExists: audit(\"directoryExists\", directory => {\n      return Array.from(files.keys()).some(path => path.startsWith(directory)) || nodeSys.directoryExists(directory)\n    }),\n    exit: nodeSys.exit,\n    fileExists: audit(\"fileExists\", fileName => {\n      if (files.has(fileName)) return true\n      // Don't let other tsconfigs end up touching the vfs\n      if (fileName.includes(\"tsconfig.json\") || fileName.includes(\"tsconfig.json\")) return false\n      if (fileName.startsWith(\"/lib\")) {\n        const tsLibName = `${tsLib}/${fileName.replace(\"/\", \"\")}`\n        return nodeSys.fileExists(tsLibName)\n      }\n      return nodeSys.fileExists(fileName)\n    }),\n    getCurrentDirectory: () => root,\n    getDirectories: nodeSys.getDirectories,\n    getExecutingFilePath: () => notImplemented(\"getExecutingFilePath\"),\n    readDirectory: audit(\"readDirectory\", (...args) => {\n      if (args[0] === \"/\") {\n        return Array.from(files.keys())\n      } else {\n        return nodeSys.readDirectory(...args)\n      }\n    }),\n    readFile: audit(\"readFile\", fileName => {\n      if (files.has(fileName)) return files.get(fileName)\n      if (fileName.startsWith(\"/lib\")) {\n        const tsLibName = `${tsLib}/${fileName.replace(\"/\", \"\")}`\n        const result = nodeSys.readFile(tsLibName)\n        if (!result) {\n          const libs = nodeSys.readDirectory(tsLib)\n          throw new Error(\n            `TSVFS: A request was made for ${tsLibName} but there wasn't a file found in the file map. You likely have a mismatch in the compiler options for the CDN download vs the compiler program. Existing Libs: ${libs}.`\n          )\n        }\n        return result\n      }\n      return nodeSys.readFile(fileName)\n    }),\n    resolvePath: path => {\n      if (files.has(path)) return path\n      return nodeSys.resolvePath(path)\n    },\n    newLine: \"\\n\",\n    useCaseSensitiveFileNames: true,\n    write: () => notImplemented(\"write\"),\n    writeFile: (fileName, contents) => {\n      files.set(fileName, contents)\n    },\n    deleteFile: (fileName) => {\n      files.delete(fileName)\n    },\n    realpath: nodeSys.realpath,\n  }\n}\n\n/**\n * Creates an in-memory CompilerHost -which is essentially an extra wrapper to System\n * which works with TypeScript objects - returns both a compiler host, and a way to add new SourceFile\n * instances to the in-memory file system.\n */\nexport function createVirtualCompilerHost(sys: System, compilerOptions: CompilerOptions, ts: TS) {\n  const sourceFiles = new Map<string, SourceFile>()\n  const save = (sourceFile: SourceFile) => {\n    sourceFiles.set(sourceFile.fileName, sourceFile)\n    return sourceFile\n  }\n\n  type Return = {\n    compilerHost: CompilerHost\n    updateFile: (sourceFile: SourceFile) => boolean\n    deleteFile: (sourceFile: SourceFile) => boolean\n  }\n\n  const vHost: Return = {\n    compilerHost: {\n      ...sys,\n      getCanonicalFileName: fileName => fileName,\n      getDefaultLibFileName: () => \"/\" + ts.getDefaultLibFileName(compilerOptions), // '/lib.d.ts',\n      // getDefaultLibLocation: () => '/',\n      getNewLine: () => sys.newLine,\n      getSourceFile: (fileName, languageVersionOrOptions) => {\n        return (\n          sourceFiles.get(fileName) ||\n          save(\n            ts.createSourceFile(\n              fileName,\n              sys.readFile(fileName)!,\n              languageVersionOrOptions ?? compilerOptions.target ?? defaultCompilerOptions(ts).target!,\n              false\n            )\n          )\n        )\n      },\n      useCaseSensitiveFileNames: () => sys.useCaseSensitiveFileNames,\n    },\n    updateFile: sourceFile => {\n      const alreadyExists = sourceFiles.has(sourceFile.fileName)\n      sys.writeFile(sourceFile.fileName, sourceFile.text)\n      sourceFiles.set(sourceFile.fileName, sourceFile)\n      return alreadyExists\n    },\n    deleteFile: sourceFile => {\n      const alreadyExists = sourceFiles.has(sourceFile.fileName)\n      sourceFiles.delete(sourceFile.fileName)\n      sys.deleteFile!(sourceFile.fileName)\n      return alreadyExists\n    }\n  }\n  return vHost\n}\n\n/**\n * Creates an object which can host a language service against the virtual file-system\n */\nexport function createVirtualLanguageServiceHost(\n  sys: System,\n  rootFiles: string[],\n  compilerOptions: CompilerOptions,\n  ts: TS,\n  customTransformers?: CustomTransformers\n) {\n  const fileNames = [...rootFiles]\n  const { compilerHost, updateFile, deleteFile } = createVirtualCompilerHost(sys, compilerOptions, ts)\n  const fileVersions = new Map<string, string>()\n  let projectVersion = 0\n  const languageServiceHost: LanguageServiceHost = {\n    ...compilerHost,\n    getProjectVersion: () => projectVersion.toString(),\n    getCompilationSettings: () => compilerOptions,\n    getCustomTransformers: () => customTransformers,\n    // A couple weeks of 4.8 TypeScript nightlies had a bug where the Program's\n    // list of files was just a reference to the array returned by this host method,\n    // which means mutations by the host that ought to result in a new Program being\n    // created were not detected, since the old list of files and the new list of files\n    // were in fact a reference to the same underlying array. That was fixed in\n    // https://github.com/microsoft/TypeScript/pull/49813, but since the twoslash runner\n    // is used in bisecting for changes, it needs to guard against being busted in that\n    // couple-week period, so we defensively make a slice here.\n    getScriptFileNames: () => fileNames.slice(),\n    getScriptSnapshot: fileName => {\n      const contents = sys.readFile(fileName)\n      if (contents && typeof contents === \"string\") {\n        return ts.ScriptSnapshot.fromString(contents)\n      }\n      return\n    },\n    getScriptVersion: fileName => {\n      return fileVersions.get(fileName) || \"0\"\n    },\n    writeFile: sys.writeFile,\n  }\n\n  type Return = {\n    languageServiceHost: LanguageServiceHost\n    updateFile: (sourceFile: import(\"typescript\").SourceFile) => void\n    deleteFile: (sourceFile: import(\"typescript\").SourceFile) => void\n  }\n\n  const lsHost: Return = {\n    languageServiceHost,\n    updateFile: sourceFile => {\n      projectVersion++\n      fileVersions.set(sourceFile.fileName, projectVersion.toString())\n      if (!fileNames.includes(sourceFile.fileName)) {\n        fileNames.push(sourceFile.fileName)\n      }\n      updateFile(sourceFile)\n    },\n    deleteFile: sourceFile => {\n      projectVersion++\n      fileVersions.set(sourceFile.fileName, projectVersion.toString())\n      const index = fileNames.indexOf(sourceFile.fileName)\n      if (index !== -1) {\n        fileNames.splice(index, 1)\n      }\n      deleteFile(sourceFile)\n    }\n  }\n  return lsHost\n}\n\nconst requirePath = () => {\n  return require(String.fromCharCode(112, 97, 116, 104)) as typeof import(\"path\")\n}\n\nconst requireFS = () => {\n  return require(String.fromCharCode(102, 115)) as typeof import(\"fs\")\n}\n"],"names":["hasLocalStorage","localStorage","error","hasProcess","process","debugLog","getItem","env","DEBUG","console","log","_message","knownLibFilesForCompilerOptions","compilerOptions","ts","array","lib","files","targetToCut","ScriptTarget","target","ES5","matches","filter","f","startsWith","toLowerCase","targetCutIndex","indexOf","pop","indexesForCutting","map","length","libCutIndex","reduce","max","current","undefined","finalCutIndex","Math","slice","addAllFilesFromFolder","workingDir","path","requirePath","fs","requireFS","walk","dir","results","readdirSync","forEach","file","join","stat","statSync","isDirectory","concat","push","fsPath","replace","content","readFileSync","includes","extname","set","notImplemented","methodName","Error","audit","name","fn","_len","arguments","args","Array","_key","res","apply","smallres","defaultCompilerOptions","_extends","getDefaultCompilerOptions","jsx","JsxEmit","React","strict","esModuleInterop","module","ModuleKind","ESNext","suppressOutputPathCheck","skipLibCheck","skipDefaultLibCheck","moduleResolution","ModuleResolutionKind","NodeJs","libize","createVirtualCompilerHost","sys","sourceFiles","Map","compilerHost","getCanonicalFileName","fileName","getDefaultLibFileName","getNewLine","newLine","getSourceFile","languageVersionOrOptions","_ref","sourceFile","get","createSourceFile","readFile","useCaseSensitiveFileNames","updateFile","alreadyExists","has","writeFile","text","deleteFile","createVirtualLanguageServiceHost","rootFiles","customTransformers","fileNames","_createVirtualCompile","fileVersions","projectVersion","languageServiceHost","getProjectVersion","toString","getCompilationSettings","getCustomTransformers","getScriptFileNames","getScriptSnapshot","contents","ScriptSnapshot","fromString","getScriptVersion","index","splice","require","String","fromCharCode","options","version","cache","lzstring","fetcher","storer","fetchlike","fetch","fsMap","prefix","storelike","Object","keys","key","removeItem","Promise","all","str","cacheKey","resolve","decompressFromUTF16","then","resp","t","setItem","compressToUTF16","_compilerOptions","_ts","tsLibDirectory","knownLibFiles","dirname","test","getLib","_projectRoot","root","nodeSys","tsLib","createDirectory","directoryExists","directory","from","some","exit","fileExists","tsLibName","getCurrentDirectory","getDirectories","getExecutingFilePath","readDirectory","result","libs","resolvePath","write","realpath","_files$get","mergedCompilerOpts","_createVirtualLanguag","languageService","createLanguageService","diagnostics","getCompilerOptionsDiagnostics","formatDiagnostics","_languageService$getP","getProgram","createFile","optPrevTextSpan","prevSourceFile","prevFullContents","prevTextSpan","createTextSpan","newText","start","newSourceFile","updateSourceFile","span","newLength"],"mappings":"wSAmBA,IAAIA,GAAkB,EACtB,IACEA,EAAqD,oBAA5BC,YAC3B,CAAE,MAAOC,GAAS,CAElB,IAAMC,EAA2C,oBAAvBC,QAEpBC,EADeL,GAAmBC,aAAcK,QAAQ,UAAcH,GAAcC,QAAQG,IAAIC,MACvEC,QAAQC,IAAM,SAACC,GAAc,MAAgC,EAAE,EAgGjFC,EAAkC,SAACC,EAAkCC,GAChF,IA2HgBC,EA1HVC,EAAMH,EAAgBG,KAAO,GAK7BC,EAAQ,CACZ,WACA,gBACA,sBACA,6BACA,6BACA,eACA,wBACA,mCACA,qBACA,mCACA,8BACA,sBACA,eACA,eACA,eACA,oBACA,oBACA,6BACA,uBACA,kBACA,4BACA,2BACA,0BACA,wBACA,0BACA,yBACA,mCACA,gCACA,kBACA,uBACA,uBACA,8BACA,kBACA,uBACA,uBACA,uBACA,yBACA,+BACA,yBACA,8BACA,iCACA,gCACA,kBACA,uBACA,uBACA,0BACA,yBACA,wBACA,kBACA,uBACA,uBACA,yBACA,yBACA,yBACA,yBACA,kBACA,uBACA,uBACA,uBACA,yBACA,0BACA,+BACA,yBACA,mCACA,kBACA,uBACA,uBACA,0BACA,yBACA,0BACA,wBACA,kBACA,wBACA,uBACA,uBACA,yBACA,yBACA,+BACA,yBACA,wBACA,6BACA,kBACA,uBACA,uBACA,8BACA,6BACA,kBACA,uBACA,yBACA,0BACA,yBACA,+BACA,yBACA,wBACA,gCACA,yBACA,6BACA,kBACA,6BACA,6BACA,0BACA,uBACA,uBACA,2BACA,yBACA,0BACA,yBACA,yBACA,yBACA,2BAGIC,EAAcJ,EAAGK,aAvHRN,EAAgBO,QAAUN,EAAGK,aAAaE,KAwHnDC,EAAUL,EAAMM,QAAO,SAAAC,GAAC,OAAIA,EAAEC,WAAU,OAAQP,EAAYQ,kBAC5DC,EAAiBV,EAAMW,QAAQN,EAAQO,OAMvCC,EAAoBd,EAAIe,KAAI,SAAAf,GAChC,IAAMM,EAAUL,EAAMM,QAAO,SAAAC,GAAC,OAAIA,EAAEC,WAAU,OAAQT,EAAIU,kBAC1D,OAAuB,IAAnBJ,EAAQU,OAAqB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"}